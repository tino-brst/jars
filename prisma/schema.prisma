generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// TODO add db level checks for positive/negative values

// TODO cascade transaction updates. Updating a field on a
// transaction(moved/received/etc) should update the updatedAt on the
// corresponding transaction

// TODO unique constraints to check that a given transaction ID only belongs to
// one jar?

// TODO should some things be readonly? i.e. a jar's currency

// TODO is there a way to check that there is enough balance in a jar to perform
// a transaction. I don't think it makes sense though, since if I'm registering
// the transaction is because it already happened

model Account {
  id              String           @id @default(uuid()) @db.Uuid
  name            String
  jars            Jar[]
  jarsWithBalance JarWithBalance[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  cards           Card[]
}

model Jar {
  id                   String                @id @default(uuid()) @db.Uuid
  name                 String?
  currency             Currency
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  accountId            String                @db.Uuid
  account              Account               @relation(fields: [accountId], references: [id])
  isPrimary            Boolean               @default(false)
  initTransaction      InitTransaction?
  // TODO rename (plural, e.g. sentTransactions)
  sentTransaction      SentTransaction[]
  receivedTransaction  ReceivedTransaction[]
  movedFromTransaction MovedTransaction[]    @relation("movedFromTransaction")
  movedToTransaction   MovedTransaction[]    @relation("movedToTransaction")
  debitTransaction     DebitTransaction[]
}

enum Currency {
  USD
  ARS
  EUR
}

model Card {
  id                String             @id @default(uuid()) @db.Uuid
  accountId         String             @db.Uuid
  account           Account            @relation(fields: [accountId], references: [id])
  type              CardType
  issuer            CardIssuer
  lastFourDigits    String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  debitTransactions DebitTransaction[]
}

enum CardType {
  DEBIT
  CREDIT
}

enum CardIssuer {
  VISA
  MASTERCARD
}

model Transaction {
  id                  String               @id @default(uuid()) @db.Uuid
  type                TransactionType
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  initTransaction     InitTransaction?
  sentTransaction     SentTransaction?
  receivedTransaction ReceivedTransaction?
  movedTransaction    MovedTransaction?
  debitTransaction    DebitTransaction?
}

enum TransactionType {
  INIT
  SENT
  RECEIVED
  MOVED
  DEBIT
}

model InitTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  jarId         String      @unique @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
}

model SentTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  jarId         String      @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
  counterparty  String
}

model ReceivedTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  jarId         String      @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
  counterparty  String
}

model MovedTransaction {
  transactionId  String      @id @unique @db.Uuid
  transaction    Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  fromJarId      String      @db.Uuid
  fromJar        Jar         @relation("movedFromTransaction", fields: [fromJarId], references: [id])
  fromAmount     Int         @default(0)
  toJarId        String      @db.Uuid
  toJar          Jar         @relation("movedToTransaction", fields: [toJarId], references: [id])
  toAmount       Int         @default(0)
  fees           Int         @default(0)
  conversionRate Float       @default(1)
}

model DebitTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  cardId        String      @db.Uuid
  card          Card        @relation(fields: [cardId], references: [id])
  jarId         String      @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
  description   String? // TODO make it required
}

view JarBalanceUpdate {
  transactionId String @db.Uuid
  jarId         String @db.Uuid
  amount        Int

  @@unique([transactionId, jarId])
}

view JarBalance {
  jarId   String @id @unique @db.Uuid
  balance Int
}

view JarWithBalance {
  id        String   @id @unique @db.Uuid
  name      String?
  currency  Currency
  createdAt DateTime
  updatedAt DateTime
  balance   Int
  accountId String   @db.Uuid
  account   Account  @relation(fields: [accountId], references: [id])
  isPrimary Boolean
}
