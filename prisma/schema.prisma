generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// TODO add db level checks for positive/negative values

// TODO cascade transaction updates. Updating a field on a
// transaction(moved/received/etc) should update the updatedAt on the
// corresponding transaction

// TODO unique constraints to check that a given transaction ID only belongs to
// one jar?

// TODO should some things be readonly? i.e. a jar's currency

// TODO is there a way to check that there is enough balance in a jar to perform
// a transaction. I don't think it makes sense though, since if I'm registering
// the transaction is because it already happened

model Account {
  id              String           @id @default(uuid()) @db.Uuid
  name            String
  jars            Jar[]
  jarsWithBalance JarWithBalance[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  cards           Card[]
}

// TODO on delete of jars, handle the possibility of deleting the primary jar.
// Whenever deleting one a new primary should be picked (if there are other
// jars). deleteJar(id, newPrimaryJarId)

model Jar {
  id                       String                         @id @default(uuid()) @db.Uuid
  name                     String?
  currency                 Currency
  createdAt                DateTime                       @default(now())
  updatedAt                DateTime                       @updatedAt
  accountId                String                         @db.Uuid
  account                  Account                        @relation(fields: [accountId], references: [id])
  isPrimary                Boolean                        @default(false)
  initTransaction          InitTransaction?
  // TODO rename (plural, e.g. sentTransactions)
  sentTransaction          SentTransaction[]
  receivedTransaction      ReceivedTransaction[]
  movedFromTransaction     MovedTransaction[]             @relation("movedFromTransaction")
  movedToTransaction       MovedTransaction[]             @relation("movedToTransaction")
  debitTransaction         DebitTransaction[]
  creditTransaction        CreditCardTransaction[]
  creditSettledTransaction CreditCardSettledTransaction[]
}

enum Currency {
  USD
  ARS
  EUR
}

model Card {
  id                            String                         @id @default(uuid()) @db.Uuid
  accountId                     String                         @db.Uuid
  account                       Account                        @relation(fields: [accountId], references: [id])
  type                          CardType
  issuer                        CardIssuer
  lastFourDigits                String
  createdAt                     DateTime                       @default(now())
  updatedAt                     DateTime                       @updatedAt
  // TODO rename to debitCardTransactions
  debitTransactions             DebitTransaction[]
  creditCardUsages              CreditCardUsage[]
  creditCardTransactions        CreditCardTransaction[]
  creditCardSettledTransactions CreditCardSettledTransaction[]
}

enum CardType {
  DEBIT
  CREDIT
}

enum CardIssuer {
  VISA
  MASTERCARD
}

model CreditCardUsage {
  id                String                       @id @default(uuid()) @db.Uuid
  cardId            String                       @db.Uuid
  card              Card                         @relation(fields: [cardId], references: [id])
  type              CreditCardUsageType
  amount            Int
  currency          Currency
  description       String
  installmentsUsage CreditCardInstallmentsUsage?
  subscriptionUsage CreditCardSubscriptionUsage?
  transactions      CreditCardTransaction[]
}

enum CreditCardUsageType {
  INSTALLMENTS
  SUBSCRIPTION
}

model CreditCardInstallmentsUsage {
  usageId           String          @id @db.Uuid
  usage             CreditCardUsage @relation(fields: [usageId], references: [id])
  installmentsCount Int
}

model CreditCardSubscriptionUsage {
  usageId String          @id @db.Uuid
  usage   CreditCardUsage @relation(fields: [usageId], references: [id])
  active  Boolean
}

model Transaction {
  id                           String                        @id @default(uuid()) @db.Uuid
  type                         TransactionType
  createdAt                    DateTime                      @default(now())
  updatedAt                    DateTime                      @updatedAt
  initTransaction              InitTransaction?
  sentTransaction              SentTransaction?
  receivedTransaction          ReceivedTransaction?
  movedTransaction             MovedTransaction?
  // TODO rename debitCardTransaction
  debitTransaction             DebitTransaction?
  creditCardTransaction        CreditCardTransaction?
  creditCardSettledTransaction CreditCardSettledTransaction?
}

enum TransactionType {
  INIT
  SENT
  RECEIVED
  MOVED
  DEBIT_CARD
  CREDIT_CARD
  CREDIT_CARD_SETTLED
}

model InitTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  jarId         String      @unique @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
}

model SentTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  jarId         String      @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
  counterparty  String
}

model ReceivedTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  jarId         String      @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
  counterparty  String
}

model MovedTransaction {
  transactionId  String      @id @unique @db.Uuid
  transaction    Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  fromJarId      String      @db.Uuid
  fromJar        Jar         @relation("movedFromTransaction", fields: [fromJarId], references: [id])
  fromAmount     Int         @default(0)
  toJarId        String      @db.Uuid
  toJar          Jar         @relation("movedToTransaction", fields: [toJarId], references: [id])
  toAmount       Int         @default(0)
  fees           Int         @default(0)
  conversionRate Float       @default(1)
}

// TODO rename to DebitCardTransaction
model DebitTransaction {
  transactionId String      @id @unique @db.Uuid
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  cardId        String      @db.Uuid
  card          Card        @relation(fields: [cardId], references: [id])
  jarId         String      @db.Uuid
  jar           Jar         @relation(fields: [jarId], references: [id])
  amount        Int         @default(0)
  // TODO make it required
  description   String?
}

// TODO makes sense to have amount as foreign key to the usage?
model CreditCardTransaction {
  transactionId          String                        @id @unique @db.Uuid
  transaction            Transaction                   @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  cardId                 String                        @db.Uuid
  card                   Card                          @relation(fields: [cardId], references: [id])
  usageId                String                        @db.Uuid
  usage                  CreditCardUsage               @relation(fields: [usageId], references: [id])
  originalAmount         Int
  originalCurrency       Currency
  effectiveFrom          DateTime
  installmentNumber      Int?
  // Optional fields defined once the transaction is settled
  settledByTransactionId String?                       @unique @db.Uuid
  settledByTransaction   CreditCardSettledTransaction? @relation(fields: [settledByTransactionId], references: [transactionId])
  jarId                  String?                       @db.Uuid
  jar                    Jar?                          @relation(fields: [jarId], references: [id])
  amount                 Int?
  conversionRate         Float?
}

model CreditCardSettledTransaction {
  transactionId       String                  @id @unique @db.Uuid
  transaction         Transaction             @relation(fields: [transactionId], references: [id])
  cardId              String                  @db.Uuid
  card                Card                    @relation(fields: [cardId], references: [id])
  jarId               String                  @db.Uuid
  jar                 Jar                     @relation(fields: [jarId], references: [id])
  amount              Int // For any fees or other adjustments
  statementClosedAt   DateTime
  settledTransactions CreditCardTransaction[]
}

view JarBalanceUpdate {
  transactionId String @db.Uuid
  jarId         String @db.Uuid
  amount        Int

  @@unique([transactionId, jarId])
}

view JarBalance {
  jarId   String @id @unique @db.Uuid
  balance Int
}

view JarWithBalance {
  id        String   @id @unique @db.Uuid
  name      String?
  currency  Currency
  createdAt DateTime
  updatedAt DateTime
  balance   Int
  accountId String   @db.Uuid
  account   Account  @relation(fields: [accountId], references: [id])
  isPrimary Boolean
}
